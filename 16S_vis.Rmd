---
title: "16S Visualization"
output:
  html_document:
    toc: yes
    df_print: paged
  html_notebook:
    theme: spacelab
    toc: yes
    toc_float: yes
---

# To clear environment
rm(list = ls())

# Set up packages
dplyr -- for data manipulation -- is installed
The pipe operator %>% comes from the dplyr packages. (part of tidyverse)
dplyr cheat sheet: https://github.com/rstudio/cheatsheets/blob/main/data-transformation.pdf

```{r load_packages, message=FALSE, warning=FALSE}
# required
library(qiime2R)
library(phyloseq)
library(tidyverse)
library(vegan)
library(indicspecies)  # for indicator species analysis
library(readxl)
library(writexl)

# optional
library(MetBrewer) # fun color palettes
```

# Read in data
I read in the QIIME artifacts as a phyloseq object. Phyloseq is an R package that has many convenient functions built in for manipulating and analyzing microbiome data. We will use the qiime2R package to import the QIIME data directly into a phyloseq object. 

```{r load_data}

getwd() 

ps <- qiime2R::qza_to_phyloseq(
  features="./data/table_dada2.qza",
  tree="./data/rooted_tree.qza",
  taxonomy="./data/taxonomy.qza",
  metadata = "./data/sample-metadata.tsv" 
)

# factor the size metadata
size_factored = c("0-0.85", "0.85-1.4", "1.4-2", "2-2.8", "2.8-4", ">4")
ps@sam_data$size.mm <- factor(ps@sam_data$size.mm, levels = size_factored)

# define variables not listed in metadata
n_replicates = 3   # A, B, C

# EPS data
pnps <- read_excel("./data/PNPS_conc.xlsx")
pnps.lb <- pnps[,2:5]
pnps.tb <- pnps[,c(2,6:8)]

```

# Basic filtering and parsing
I will do a bit of manipulation using phyloseq functions, then we will use the suite of tidyverse packages to do more data manipulation. 
Let's start with getting relative abundance data.

```{r apply_filt}
# remove Mitochondria and Chloroplasts (removes Eukaryotes)
ps_filt0 <- phyloseq::subset_taxa(ps, ! Family %in% c("Mitochondria", "Chloroplast"))

# remove unclassified sequences
ps_filt0 <- phyloseq::subset_taxa(ps, Kingdom != "Unassigned")

# define minimum depth to rarefy
rarefy_level <- min(sample_sums(ps_filt0))  # lowest number of ASVs per sample
# apply rarefaction
ps_filt <-rarefy_even_depth(ps_filt0, rarefy_level,
  rngseed = 7, replace = TRUE, trimOTUs = TRUE, verbose = TRUE)
#ps_filt_r <-rarefy_even_depth(ps_filt0, rarefy_level,
  #rngseed = 7, replace = TRUE, trimOTUs = TRUE, verbose = TRUE)
 

# Remove taxa not seen more than 3 times in at least 20% of the samples. 
# This protects against an OTU with small mean & trivially large C.V.
#ps_filt = filter_taxa(ps_filt_r, function(x) sum(x > 3) > (0.2*length(x)), TRUE)

# relative abundance
ps_rel <- phyloseq::transform_sample_counts(ps_filt, function(x) x*100/sum(x))  # convert to %


# Show how much data was filtered out
print(paste("Number of ASVs originally:", ntaxa(ps))) # how many ASVs are there?
#print(paste("Number of ASVs after rarefaction:", ntaxa(ps_filt_r)))
print(paste("Number of ASVs after filtering:", ntaxa(ps_filt)))
```

# Format as data frames

This chunk saves the taxonomy, metadata, and count tables as data frames. In these tables, each row is a unique ASV. 

The pipe operator %>% comes from the dplyr packages. 

```{r reformat}
taxonomy <- as.data.frame(ps_rel@tax_table) %>% 
  rownames_to_column(var = "seq") # change the ASV ID to a column, not a row name

head(taxonomy)

metadata <- as.data.frame(as.matrix(ps_rel@sam_data)) %>% 
  rownames_to_column(var = "sample")
# factor the size metadata
metadata$size.mm <- factor(metadata$size.mm, levels = size_factored)

head(metadata)

table_rel <- as.data.frame(ps_rel@otu_table) %>% 
  rownames_to_column(var = "seq")

head(table_rel)

``` 
# Data Manipulation: Combine into wide dataframe

This combines taxonomy and relative abundance in a wide dataframe. Then, it exports it to an excel spreadsheet. 
This format is easier to view the data.

```{r combine_wide}

# removes some columns from taxonomy
tax_short <- taxonomy %>%
  group_by(Genus,Species,seq) %>%
  summarise()

# Adds table_rel to taxonomy
table_rel_wide <-  tax_short %>%
  left_join(table_rel, join_by(seq))  # join taxonomy by the sequence ID

head(table_rel_wide)

write_xlsx(table_rel_wide, "./results/table_rel_wide.xlsx")

``` 
# Data Manipulation: Combine into long dataframe

This chunk manipulates the relative abundance table and combines it with the taxonomy table. We used the pivot_longer function to make this into a "long" dataframe, which is the desired format for using ggplot2. Read a bit more about long format here: http://eriqande.github.io/rep-res-web/lectures/ggplot_2_reshape_facets_stats.html. The long format will seem very chaotic, but I promise it will be extremely useful for plotting and data analysis tasks going forward.

```{r combine_long}

table_rel_long <- table_rel %>% 
  pivot_longer(cols = !seq, names_to = "sample", values_to = "rel_ab") %>% # make a "long" dataframe
  left_join(taxonomy, join_by(seq)) %>% # join taxonomy by the sequence ID
  left_join(metadata, join_by(sample)) # join metadata by the sample ID

head(table_rel_long)

```


# Subsetting and plotting
We can use a variety of filtering functions from dplyr to manipulate data for more concise plots. For example, we could select specific bacteria to look for, or group all members of the same family or genus together. 

Here, we define the genus we want to filter the data by.
We also order it how we want it to be displayed on the x-axis.

```{r subset_genus}
n_asv = 25  # number of ASVs to include in the plot 

# Identify top ASVs by mean abundance (excluding NA Genera)
top_asvs <- table_rel_long %>%
  filter(!is.na(Genus)) %>%
  group_by(Genus, seq) %>%
  summarise(mean_ab = mean(rel_ab), .groups = "drop") %>%  
  arrange(desc(mean_ab)) %>%  
  slice_head(n = n_asv) 
  
# Sum abundances of selected ASVs per sample
genus_sum <- table_rel_long %>%
  filter(seq %in% top_asvs$seq) %>%
  group_by(sample, size.mm, Genus) %>%
  summarise(sum_ab = sum(rel_ab), .groups = "drop") 

# Average per Genus across all samples
genus_avg <- genus_sum %>%
  group_by(Genus) %>%
  summarise(
    mean_ab = mean(sum_ab),
    sd_ab = sd(sum_ab),
    .groups = "drop"
  ) %>%
  arrange(desc(mean_ab)) %>%
  # Factor the genus based on relative abundance
  mutate(Genus = forcats::fct_reorder(Genus, mean_ab, .desc = TRUE))

# Define Genus factor levels
genus_levels <- levels(genus_avg$Genus)

top_asvs <- top_asvs %>%
  mutate(Genus = factor(Genus, levels = genus_levels))

# Average per Genus across replicates
genus_size <- genus_sum %>%
  group_by(Genus, size.mm) %>%
  summarise(
    mean_ab = mean(sum_ab),
    sd_ab = sd(sum_ab)
  ) %>%
  mutate(Genus = factor(Genus, levels = genus_levels))

### Names
genus_names <- genus_avg$Genus 
seq_names <- top_asvs$seq
```
# Rank Abundance Curve (collapses size)
This shows the genera that have the highest relative abundance, averaged for all samples.
The scatter plot shows the different ASVs that make up each genus.
Most genera are only one ASV, and some are composed of several. 
The bar plot adds up the relative abundance of each ASV.
NA are samples for which the genus was not identified.
This shows a subset of the data -- "n_asv" specifies how many ASVs to include.
```{r rank_abundance_average}

#fct_rev: puts largest rel_ab at top
ggplot(genus_avg, aes(x = fct_rev(Genus), y = mean_ab)) +
  geom_col(fill = "steelblue", width = 0.6) +
  geom_errorbar(aes(ymin = mean_ab - sd_ab, ymax = mean_ab + sd_ab), 
                width = 0.2, color = "black") +
  geom_point(
    data = top_asvs,
    aes(x = fct_rev(Genus), y = mean_ab), 
    color = "black",
    #position = position_jitter(width = 0.2),  # optional: adds slight jitter
    size = 2
  ) +
  labs(
    title = "Genus-Level Relative Abundance (with ASV overlay)",
    y = "Mean Relative Abundance [%]",
    x = "Genus"
  ) +
  theme_minimal() +
  coord_flip()

fname = paste("./results/genus/abund_avg.png") 
ggsave(fname)
```
# Rank Abundance Curve with size
This subsets the data to only include the seqs with the highest n_asv relative abundance.
So, the relative abundance is not the same as the sum for all ASVs per genus.
This is to be consistent with the data shown in the previous plot.

Do NOT use mean to average here because, when a sample has more than one ASV, 
then that calculation would average across each different ASV.

```{r rank_abundance_size}

p <- ggplot(genus_size, aes(x = fct_rev(Genus), y = mean_ab, fill = as.factor(size.mm))) +
    geom_col(
    position = position_dodge(width = 0.8),
    width = 0.7
  ) +
  geom_errorbar(
    aes(ymin = pmax(mean_ab - sd_ab, 0), ymax = mean_ab + sd_ab),
    width = 0.2,
    position = position_dodge(width = 0.8)
  ) +
  scale_fill_manual(
    values = met.brewer("Hiroshige", 6),
    name = "Size (mm)"
  ) +
  scale_y_continuous(
    expand = expansion(mult = c(0, 0.1))  # Add 10% space above
  ) +
  labs(
    x = "Genus",
    y = "Mean Relative Abundance [%]",
    title = "Genus-Level Abundance by Size Fraction"
  ) +
  theme_minimal() +
  coord_flip()

# Save plot
fname <- "./results/genus/abund_size.png"
ggsave(fname, plot = p, width = 10, height = 12, dpi = 300)

```

```{r rank_abundance_size2}

# Plot  
p <- genus_size %>%
  ggplot(aes(x = Genus, y = mean_ab, fill = size.mm)) +
  geom_bar(stat = "identity", position = "dodge") +  
  geom_errorbar(
    aes(ymin = mean_ab - sd_ab, ymax = mean_ab + sd_ab),
    width = 0.2,
    position = position_dodge(width = 0.8)
  ) +
  scale_fill_manual(values=met.brewer("Hiroshige", 6)) +
  xlab("Genus") +
  ylab("Relative Abundance [%]") +
  coord_flip()

# Save plot
fname <- "./results/genus/abund_size2.png"
ggsave(fname, plot = p)

print(p)

```
# Single scatter plot
This summarizes the relative abundance for one genus at a time.
It shows the variation from the biological replicates.

```{r plot_scatter_single}
for (i in 1:length(genus_names)) {
  
  gs <- if (is.na(genus_names[i])) {
    filter(table_rel_long, is.na(Genus), seq %in% fct_seq_levels)
  } else {
    filter(table_rel_long, Genus %in% genus_names[i], seq %in% fct_seq_levels)
  }
  
  gs %>%  
    ggplot(aes(x = size.mm, y = rel_ab, fill = seq)) +
    geom_point(
      shape = 21,
      color = "black",
      size = 3,
      stroke = 1
    ) +
    labs(title = genus_names[i]) +
    xlab("Sieve Range [mm]") +
    ylab("Relative Abundance [%]")  
  
  fname = paste("./results/genus/genus_",genus_names[i], ".png", sep = "") 
  ggsave(fname)
}
```
# Multiple subplots
This combines multiple genera in subplots
```{r plot_scatter_multiple}

gs.group_plot <- table_rel_long %>%
  filter(Genus %in% c("Ca_Contendobacter", "Ca_Phosphoribacter"), seq %in% fct_seq_levels)

### plot
gs.group_plot %>%
  ggplot(aes(x = size.mm, y = rel_ab, fill = seq)) + 
  facet_wrap(~Genus, nrow = 1) +
  geom_point(
    shape = 21,
    color = "black",    # black outline
    size = 3,
    stroke = 1
  ) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust = 1)) +
  xlab("Sieve Range [mm]") +
  ylab("Sum of Relative Abundance [%]")

ggsave("./results/genus_group.png")
```

# Alpha Diversity
```{r diversity_plot}
div_type = c("Shannon")

# Base plot (no fill here)
p <- plot_richness(
  ps_filt, 
  x = "size.mm", 
  measures = div_type
)

# Add custom axis labels and theme
p <- p +
  xlab("Sieve Range [mm]") +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust = 1))

# Save the plot
filename <- paste0("./results/diversity/diversity_", div_type, ".png")
ggsave(filename, plot = p)

print(p)

```

# Ordination - NMDS
tutorial: https://joey711.github.io/phyloseq/plot_ordination-examples.html

```{r ordination-nmds}
cols <- met.brewer("Hiroshige", 6) 

ps.ord <- ordinate(ps_filt, "NMDS", "bray")
p1 = plot_ordination(ps_filt, ps.ord, type="samples", color="size.mm", title="NMDS") + 
                     scale_color_manual(values=cols)  +
                     labs(color = "Size (mm)")
# seperate the plots so they aren't overlayed
#p1 = p1 + facet_wrap(~size.mm, 2)  # 2 is the number of rows
  
print(p1)

ggsave("./results/ordination-NMDS.png", plot = p1, scale = 1,dpi = 300)
```
# Ordination - PCoA
```{r ordination-pcoa}
ps.ord <- ordinate(ps_filt, "PCoA", "unifrac")
p1 = plot_ordination(ps_filt, ps.ord, type="samples", color="size.mm", title="PCoA") + 
                     scale_color_manual(values=cols) + 
                     labs(color = "Size (mm)")
# seperate the plots so they aren't overlayed
#p1 = p1 + facet_wrap(~size.mm, 2)  # 2 is the number of rows

print(p1)
ggsave("./results/ordination-PCoA.png", plot = p1, scale = 1,dpi = 300)
```

# Distance
What is the difference between weighted and unweighted unifrac

```{r calculate_distance}
ps_filt.dist <- distance(ps_filt, method = "wunifrac" ) # weighted
show(ps_filt.dist)
```
R statistic ranges from -1 to 1. 0 is random. 
```{r plot_anosim}
ps_filt.ano <- anosim(ps_filt.dist, metadata$size.mm, permutations = 9999)
summary(ps_filt.ano)

# Open a PNG device
png("./results/anosim_plot.png", width = 800, height = 600)

# Plot the ANOSIM result
plot(ps_filt.ano,
     xlab = "Size [mm]",
     ylab = "Dissimilarity Ranks")

# Close the device to save the file
dev.off()
```
```{r plot_species}
seq_names = table_rel[,1]    # define the sequence names
table_rel2 = table_rel[,-1]  # removes the sequence names from the matrix
rownames(table_rel2) <- seq_names # label the rows with the sequences
table_rel2 = t(table_rel2)   # transpose

group_names = metadata$size.mm

inv = multipatt(table_rel2, group_names, func = "r.g", control = how(nperm=9999))
summary(inv)
```



