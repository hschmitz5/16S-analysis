---
title: "16S Visualization"
output:
  html_document:
    toc: yes
    df_print: paged
  html_notebook:
    theme: spacelab
    toc: yes
    toc_float: yes
---

# To clear environment
rm(list = ls())

# Set up packages
dplyr -- for data manipulation -- is installed
The pipe operator %>% comes from the dplyr packages. (part of tidyverse)
dplyr cheat sheet: https://github.com/rstudio/cheatsheets/blob/main/data-transformation.pdf

```{r load_packages, message=FALSE, warning=FALSE}
# required
library(qiime2R)
library(phyloseq)
library(tidyverse)
library(vegan)
library(indicspecies)  # for indicator species analysis
library(writexl)

# optional
library(MetBrewer) # fun color palettes
```

# Read in data
I read in the QIIME artifacts as a phyloseq object. Phyloseq is an R package that has many convenient functions built in for manipulating and analyzing microbiome data. We will use the qiime2R package to import the QIIME data directly into a phyloseq object. 

```{r load_ps}

getwd() 

ps <- qiime2R::qza_to_phyloseq(
  features="./data/table_dada2.qza",
  tree="./data/rooted_tree.qza",
  taxonomy="./data/taxonomy.qza",
  metadata = "./data/sample-metadata.tsv" 
)

# factor the size metadata
size_factored = c("0-0.85", "0.85-1.4", "1.4-2", "2-2.8", "2.8-4", ">4")
ps@sam_data$size.mm <- factor(ps@sam_data$size.mm, levels = size_factored)

```

# Basic filtering and parsing
I will do a bit of manipulation using phyloseq functions, then we will use the suite of tidyverse packages to do more data manipulation. Let's start with getting relative abundance data.

```{r apply_filt}
# remove Mitochondria and Chloroplasts (removes Eukaryotes)
ps_filt0 <- phyloseq::subset_taxa(ps, ! Family %in% c("Mitochondria", "Chloroplast"))

# remove unclassified sequences
ps_filt0 <- phyloseq::subset_taxa(ps, Kingdom != "Unassigned")

# define minimum depth to rarefy
rarefy_level <- min(sample_sums(ps_filt0))  # lowest number of ASVs per sample
# apply rarefaction
ps_filt_r <-rarefy_even_depth(ps_filt0, rarefy_level,
  rngseed = 7, replace = TRUE, trimOTUs = TRUE, verbose = TRUE)

# Remove taxa not seen more than 3 times in at least 20% of the samples. 
# This protects against an OTU with small mean & trivially large C.V.
ps_filt = filter_taxa(ps_filt_r, function(x) sum(x > 3) > (0.2*length(x)), TRUE)

# relative abundance
ps_rel <- phyloseq::transform_sample_counts(ps_filt, function(x) x*100/sum(x))  # convert to %

# filters out taxa that are less than 0.25% abundant for at least one sample
ps_rel_s = filter_taxa(ps_rel, function(x) max(x) > 0.25, TRUE)  # for visualizing abundance only


# Show how much data was filtered out
print(paste("Number of ASVs originally:", ntaxa(ps))) # how many ASVs are there?
print(paste("Number of ASVs after rarefaction:", ntaxa(ps_filt_r)))
print(paste("Number of ASVs after filtering:", ntaxa(ps_filt)))
print(paste("Number of ASVs in small mat:", ntaxa(ps_rel_s)))
```
```{r genus_abundance}

# Merges ASVs that have the same taxonomy rank (Genus)
ps_rel_genus = tax_glom(ps_rel, taxrank = "Genus")

# Calculate taxa sum of the selected samples
# rowSums adds relative abundance across all samples (divide by number of samples so % makes sense)
top10 = head(sort(rowSums(otu_table(ps_rel_genus)/nsamples(ps)), decreasing = TRUE), 10) 

# Combine count and taxonomyTable
top10 = cbind(as.data.frame(tax_table(ps_rel_genus)[names(top10),]), "Relative abundance [%]" = top10)

genus_names = top10[,6]
```

# Format as data frames

This chunk saves the taxonomy, metadata, and count tables as data frames. In these tables, each row is a unique ASV. 

The pipe operator %>% comes from the dplyr packages. 

```{r reformat}
taxonomy <- as.data.frame(ps_rel@tax_table) %>% 
  rownames_to_column(var = "seq") # change the ASV ID to a column, not a row name

head(taxonomy)

metadata <- as.data.frame(as.matrix(ps_rel@sam_data)) %>% 
  rownames_to_column(var = "sample")
# factor the size metadata
metadata$size.mm <- factor(metadata$size.mm, levels = size_factored)

head(metadata)

table_rel <- as.data.frame(ps_rel@otu_table) %>% 
  rownames_to_column(var = "seq")

head(table_rel)

#### adds genus to table_rel
tax_short <- taxonomy[,c(1,7,8)]  # keep seq, Genus, Species
tax_short2 <- tax_short[order(tax_short$Genus), ]  # sort alphabetically

table_rel_plus <-  tax_short2 %>%
  left_join(table_rel, join_by(seq))  # join taxonomy by the sequence ID

head(table_rel_plus)

write_xlsx(table_rel_plus, "./results/table_rel_plus.xlsx")


### Filters out more taxa

table_rel_s <- as.data.frame(ps_rel_s@otu_table) %>% 
  rownames_to_column(var = "seq")

#### Merges ASVs that have the same taxonomy rank (Genus)

#table_rel2 <- as.data.frame(ps_rel_genus@otu_table) %>% 
  #rownames_to_column(var = "seq")


#write_xlsx(table_rel, "./results/table_rel.xlsx")

``` 

# Data Manipulation

This chunk manipulates the relative abundance table and combines it with the taxonomy table. We used the pivot_longer function to make this into a "long" dataframe, which is the desired format for using ggplot2. Read a bit more about long format here: http://eriqande.github.io/rep-res-web/lectures/ggplot_2_reshape_facets_stats.html. The long format will seem very chaotic, but I promise it will be extremely useful for plotting and data analysis tasks going forward.

```{r combine_mats}
table_rel_s_long <- table_rel_s %>% 
  pivot_longer(cols = !seq, names_to = "sample", values_to = "rel_ab") %>% # make a "long" dataframe
  left_join(taxonomy, join_by(seq)) %>% # join taxonomy by the sequence ID
  left_join(metadata, join_by(sample)) # join metadata by the sample ID

head(table_rel_s_long)


#table_rel_long <- table_rel %>% 
  #pivot_longer(cols = !seq, names_to = "sample", values_to = "rel_ab") %>% # make a "long" dataframe
  #left_join(taxonomy, join_by(seq)) %>% # join taxonomy by the sequence ID
  #left_join(metadata, join_by(sample)) # join metadata by the sample ID

#head(table_rel_long)
```


# Subsetting and plotting
We can use a variety of filtering functions from dplyr to manipulate data for more concise plots. For example, we could select specific bacteria to look for, or group all members of the same family or genus together. Let's do a simple example - we will plot the abundance of the genus Zoogleoa from each sampling location. First, let's see what the data looks like when we filter it to our specifications. 

Here, we define the genus we want to filter the data by.
We also order it how we want it to be displayed on the x-axis.

Adding duplicate.id to "group_by" seperates the data 
```{r sort_genus}
# make a data frame of first two lines
genus_summary <- table_rel_long %>% # perform some functions on table_rel
  group_by(Genus, size.mm, duplicate.id) %>% # group at the genus level, we will use this to sum up everything that has the same genus 
  # sum up the relative abundance of each unique Genus at each unique combination of date and location 
  summarise(sum_ab = sum(rel_ab)) 


genus_summary2 <- table_rel_s_long %>% # perform some functions on table_rel
  group_by(Genus, seq, size.mm, duplicate.id) %>% # group at the genus level, we will use this to sum up everything that has the same genus 
  summarise(rel_ab) #%>% # sum up the relative abundance of each unique Genus at each unique combination of date and location

# Test
sum(genus_summary[,4]/nsamples(ps))
sum(genus_summary2[,5]/nsamples(ps))



```
# Scatter plots look better with duplicates

I considered making a boxplot, but I only have two data points. It is recommended to make box plots with more than 5 data points.

Ca. Accumilibacter is a POA.

# Single scatter plot
```{r plot_scatter_loop}
#for (i in 1:10) {
i = 2
  gs <- genus_summary2 %>% # how to pipe data (dplyr filter)
    filter(Genus == genus_names[i]) # i
  
  gs %>%  
    ggplot(aes(x = size.mm, y = rel_ab, fill = seq)) +
    #ggplot(aes(x = size.mm, y = sum_ab, fill = seq)) +
    geom_point(
      shape = 21,
      color = "black",
      size = 3,
      stroke = 1
    ) +
    #scale_fill_manual(
    #values = c("A" = "#4E2A84", "B" = NA, "C" = "gray"),   # A = filled, B = empty
    #na.value = "white"                       # fallback fill color for NA
    #) +
    labs(title = genus_names[i]) + #, fill = "Replicate ID") +
    xlab("Sieve Range [mm]") +
    ylab("Relative Abundance [%]")  # Sum of
  
  fname = paste("./results/genus_",genus_names[i], ".png", sep = "") # i
  ggsave(fname)
#}
```


# Multiple subplots
```{r plot_scatter_multiple}
# Ca_Contendobacter, Ca_Competibacter, Ca_Phosphoribacter
gs.group_plot <- genus_summary2 %>%
  filter(Genus %in% c(genus_names[1], genus_names[2], genus_names[3])) 
show(gs.group_plot)

### plot
gs.group_plot %>%
  ggplot(aes(x = size.mm, y = rel_ab, fill = seq)) + 
  #ggplot(aes(x = size.mm, y = sum_ab)) +  #, fill = duplicate.id)) + 
  facet_wrap(~Genus, nrow = 1) +
  geom_point(
    shape = 21,
    color = "black",    # black outline
    size = 3,
    stroke = 1
  ) +
  #scale_fill_manual(
    #values = c("A" = "#4E2A84", "B" = NA, "C"="gray"),
    #na.value = "white"
  #) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust = 1)) +
  #labs(fill = "Replicate ID") +
  xlab("Sieve Range [mm]") +
  ylab("Sum of Relative Abundance [%]")

ggsave("./results/genus_group.png")
```

We can save that table as a new R data frame, or we can pipe that data directly into a ggplot2 command. Notice that the timepoint column is the "character" class rather than a numeric class like a "double" Let's add a modification so the timepoint column is correctly classified.


# Alpha Diversity
```{r diversity_plot}

# Base plot (no fill here)
p <- plot_richness(ps_filt, 
                   x = "size.mm", 
                   measures = c("Shannon"))

# Add custom geom_point with manual fill scale
p + 
  #scale_fill_manual(
    #values = c("A" = "#4E2A84", "B" = NA, "C" = "gray"),
    #na.value = "white"
  #) +
  #labs(fill = "Replicate ID") +
  xlab("Sieve Range [mm]") +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust = 1))

ggsave("./results/diversity.png")
```

# Ordination 
tutorial: https://joey711.github.io/phyloseq/plot_ordination-examples.html

Try it here ordination B diversity
```{r ordination-nmds}
cols <- c('red','orange','green', 'blue', 'violet', 'black')

ps.ord <- ordinate(ps_filt, "NMDS", "bray")
p1 = plot_ordination(ps_filt, ps.ord, type="samples", color="size.mm", title="NMDS") + 
                     scale_color_manual(values=cols)  +
                     labs(color = "Size (mm)")
# seperate the plots so they aren't overlayed
#p1 = p1 + facet_wrap(~size.mm, 2)  # 2 is the number of rows
  
print(p1)

ggsave("./results/ordination-NMDS.png", plot = p1, scale = 1,dpi = 300)
```
Try pcoa instead
```{r ordination-pcoa}
ps.ord <- ordinate(ps_filt, "PCoA", "unifrac")
p1 = plot_ordination(ps_filt, ps.ord, type="samples", color="size.mm", title="PCoA") + 
                     scale_color_manual(values=cols) + 
                     labs(color = "Size (mm)")
# seperate the plots so they aren't overlayed
#p1 = p1 + facet_wrap(~size.mm, 2)  # 2 is the number of rows

print(p1)
ggsave("./results/ordination-PCoA.png", plot = p1, scale = 1,dpi = 300)
```


# Distance
What is the difference between weighted and unweighted unifrac

```{r calculate_distance}
ps_filt.dist <- distance(ps_filt, method = "wunifrac" ) # weighted
show(ps_filt.dist)
```
R statistic ranges from -1 to 1. 0 is random. What is -1?
```{r plot_anosim}
ps_filt.ano <- anosim(ps_filt.dist, metadata$size.mm, permutations = 9999)
summary(ps_filt.ano)

# Open a PNG device
png("./results/anosim_plot.png", width = 800, height = 600)

# Plot the ANOSIM result
plot(ps_filt.ano,
     xlab = "Size [mm]",
     ylab = "Dissimilarity Ranks")

# Close the device to save the file
dev.off()
```
```{r plot_species}
seq_names = table_rel[,1]    # define the sequence names
table_rel2 = table_rel[,-1]  # removes the sequence names from the matrix
rownames(table_rel2) <- seq_names # label the rows with the sequences
table_rel2 = t(table_rel2)   # transpose

group_names = metadata$size.mm

inv = multipatt(table_rel2, group_names, func = "r.g", control = how(nperm=9999))
summary(inv)
```
